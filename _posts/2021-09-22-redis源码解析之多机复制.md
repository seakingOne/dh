---
layout: post
title:  "redis源码解析之多机复制"
date:   2021-09-22
desc: "redis 集群 复制"
keywords: "redis 集群 复制"
categories: [Database]
tags: [C/C++,redis,服务端]
icon: icon-html
---

在Redis中，用户可以通过slaveof命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称被复制的服务器为主服务器<br/>
，假设我们现在有2个Redis服务器，地址为127.0.0.1:6379和127.0.0.1:16379，如果我们向服务器127.0.0.1:16379发送以下命令：
    
    127.0.0.1:16379> slaveof 127.0.0.1:6379
    OK

那么服务器127.0.0.1:16379就是127.0.0.1:6379的从服务器，当然所有在主服务器上的操作，在从服务器中也会执行一次<br/>

Redis的复制分为同步和命令传播2个操作，同步操作用于将从服务器的数据库状态更新至主服务器当前所处的状态<br/>
命令传播则是用于在主服务器的数据库状态被修改，出现主从数据不一致时，让主从服务器重新处于一致状态<br/>

同步操作步骤：<br/>
1、从服务向主服务器发送SYNC命令<br/>
2、收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用缓冲区记录从现在开始执行的所有写命令<br/>
3、当主服务器的BGSAVE命令执行完毕后，主服务器会将BGSAVE生成的RDB文件传输给从服务器，从服务器载入RDB文件，开始执行写操作<br/>
4、主服务器将记录在缓冲区的所有写操作命令发送给从服务器，从服务器执行命令<br/>
   
    我们知道在redis.c中定义了命令需要执行的方法{"slaveof",slaveofCommand,3,"ast",0,NULL,0,0,0,0,0}
    void slaveofCommand(redisClient *c) {
        /* 表示集群模式下该节点不能作为从节点 */
        if (server.cluster_enabled) {
            addReplyError(c,"SLAVEOF not allowed in cluster mode.");
            return;
        }
    
        /* 如果当前是SLAVEOF NO ONE命令，则表示取消复制模式 */
        if (!strcasecmp(c->argv[1]->ptr,"no") &&
            !strcasecmp(c->argv[2]->ptr,"one")) {
            if (server.masterhost) {
                replicationUnsetMaster();
                sds client = catClientInfoString(sdsempty(),c);
                redisLog(REDIS_NOTICE,
                    "MASTER MODE enabled (user request from '%s')",client);
                sdsfree(client);
            }
        } else {
            PORT_LONG port;
    
            if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != REDIS_OK))
                return;
    
            /* 校验当前是否已经进入复制模式了，则直接返回 */
            if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr)
                && server.masterport == port) {
                redisLog(REDIS_NOTICE,"SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.");
                addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
                return;
            }
            /* 该方法中会set主服务器ip与host，需要注意的是SYNC命令是异步的，所有会直接返回连接成功，实际的复制工作在返回OK之后 */
            replicationSetMaster(c->argv[1]->ptr, (int)port);                       WIN_PORT_FIX /* cast (int) */
            sds client = catClientInfoString(sdsempty(),c);
            redisLog(REDIS_NOTICE,"SLAVE OF %s:%d enabled (user request from '%s')",
                server.masterhost, server.masterport, client);
            sdsfree(client);
        }
        addReply(c,shared.ok);
    }
    
    server中保存结构
    struct redisServer {
    
        char *masterhost;
        
        int masterport;
    
    }   
    
    
真正的任务调度是在serverCron中操作:<br/>

    /* Replication cron function -- used to reconnect to master and
         * to detect transfer failures. */
    run_with_period(1000) replicationCron();  //表示每1s执行复制操作   
    
    /* Check if we should connect to a MASTER */
    if (server.repl_state == REDIS_REPL_CONNECT) {
        redisLog(REDIS_NOTICE,"Connecting to MASTER %s:%d",
            server.masterhost, server.masterport);
        if (connectWithMaster() == REDIS_OK) {
            redisLog(REDIS_NOTICE,"MASTER <-> SLAVE sync started");
        }
    }
   
命令传播：<br/>
     