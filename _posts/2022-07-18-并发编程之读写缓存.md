---
layout: post
title:  "并发编程之读写缓存"
date:   2022-07-18
desc: "并发编程 管程 信号量 读写锁"
keywords: "并发编程 管程 信号量 读写锁"
categories: [Article]
tags: [Java, 并发, 读写锁]
icon: icon-html
---

前面简单了解了下管程与信号量，理论上用这2个可以解决所有的并发问题，那么Java jdk并发包里面还有很多其他的工具类，原因：分场景优化性能，提升易用性。一种常见的使用场景，读多写少场景ReadWriteLock。<br/>

读写锁，并不是 Java 语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则：允许多个线程同时读共享变量；只允许一个线程写共享变量；如果一个写线程正在执行写操作，此时禁止读线程读共享变量。<br/>
读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。
    
    class Cache<K,V> {
      final Map<K, V> m =
        new HashMap<>();
      final ReadWriteLock rwl = 
        new ReentrantReadWriteLock();
      final Lock r = rwl.readLock();
      final Lock w = rwl.writeLock();
     
      V get(K key) {
        V v = null;
        //读缓存
        r.lock();         
        try {
          v = m.get(key); 
        } finally{
          r.unlock();     
        }
        //缓存中存在，返回
        if(v != null) {   
          return v;
        }  
        //缓存中不存在，查询数据库
        w.lock();         
        try {
          //再次验证
          //其他线程可能已经查询过数据库
          v = m.get(key); 
          if(v == null){  
            //查询数据库
            v=省略代码无数
            m.put(key, v);
          }
        } finally{
          w.unlock();
        }
        return v; 
      }
    }
