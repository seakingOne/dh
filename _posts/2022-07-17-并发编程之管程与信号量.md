---
layout: post
title:  "并发编程之管程与信号量"
date:   2022-07-17
desc: "并发编程 管程 信号量"
keywords: "并发编程 管程 信号量"
categories: [Article]
tags: [Java, 并发]
icon: icon-html
---

大家都知道，一般我们所遇到的并发问题的根源来自于数据可见性、编译器的代码执行优化这2点
数据可见性：多核cpu缓存导致出现的问题
编译器优化：优化代码的结构和执行顺序<br/>
常见的优化手段也是比较清楚的，加Volatile关键字，可以禁用cpu的缓存

而我们今天介绍的管程与信号量，也是解决并发问题的万能钥匙<br/>
Java所采用的管程技术，synchronized, wait,notify, notifyAll这三个方法都是管程的组成部分，管程与信号量是等价的，
但是管程更容易使用，所以Java选择了管程

信号量：Semaphore
整体来说，Semaphore模型是比较简单的，简单来说，一个计数器，一个等待队列，三个方法（init， down， up）
init用于设置计数器的初始值，down计数器-1，如果当前计数器值<0，当前线程被阻塞，up计数器+1，如果此时计数器值<=0，唤醒
等待队列中得一个线程，并从等待队列中移除，这里的三个方法都是原子性的，比如

    static int count;
    //初始化信号量
    static final Semaphore s = new Semaphore(1);
    //互斥
    static void addOne() {
    
        s.acquire();
        try {
            count += 1; 
        } finally {
            s.release();
        }
    
    }
    
    信号量是如何保证互斥的，假设2个线程T1和T2同时访问addOne()方法，当他们同时调用acquire（）的时候，由于acquire是一个原子操作，
    所以只能有一个线程（T1）把信号量里的计数器减为0，另外一个T2则是把计数器值变为-1,从这边看到，其实信号量适合做一个限流器



Java jdk并发包内容很丰富，最明显的还是Lock和Condition2个接口来实现管程，其中Lock用于解决互斥问题，Condition用于解决
同步问题。



    
    
    